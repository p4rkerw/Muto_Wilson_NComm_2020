
library(Signac) # 0.1.5 ..
library(Seurat) # 3.0.2 ..
library(Gviz) # ..
library(biomaRt) # ..
library(dplyr) # ..
library(plyranges) # ..
library(EnsDb.Hsapiens.v86) # ..
library(cicero)
library(data.table)
library(openxlsx)
library(zoo) # has rollapply function required for CalculateCoverages
library(here)


# identify celltype-specific dac between control and diabetes and generate granges object
FindDacGRanges <- function(seuratAtacSub, clusterID) {
  Idents(seuratAtacSub) <- "celltype"
  DefaultAssay(seuratAtacSub) <- 'peaks'
  dac <- FindMarkers(seuratAtacSub, ident.1 = clusterID,
                     test.use = 'LR', latent.vars = "peak_region_fragments") # find dac
  dac <- dac[dac$p_val < 0.05, ]
  cf <- ClosestFeature(rownames(dac), annotation=EnsDb.Hsapiens.v86, sep=c(':','-'))
  dac <- cbind(dac, symbol=cf$gene_name, distance=cf$distance)
  dacGRanges <- StringToGRanges(regions = rownames(dac[dac$p_val < 0.05, ]), sep = c(":", "-"))
  mcols(dacGRanges)$lfc <- dac$avg_logFC # add the log fold change as a meta data column with Gviz package
  mcols(dacGRanges)$closestGene <- dac$gene
  mcols(dacGRanges)$distance <- dac$distance
  return(dacGRanges)
}

# identify celltype-specific deg 
FindDegGRanges <- function(seuratRnaSub, clusterID) {
  Idents(seuratRnaSub) <- "celltype"
  DefaultAssay(seuratRnaSub) <- 'SCT'
  deg <- FindMarkers(seuratRnaSub, ident.1 = clusterID) # find all cluster-specific deg
  deg <- deg[deg$p_val < 0.05, ]
  human = useMart("ensembl", dataset = "hsapiens_gene_ensembl")
  bm <- getBM(attributes = c("hgnc_symbol","chromosome_name", "start_position", "end_position","ensembl_gene_id"),
              filters = "hgnc_symbol", values = rownames(deg), mart = human) # get genomic coordinates of degs
  deg$hgnc_symbol <- rownames(deg)
  degCoord <- merge(bm, deg, by = "hgnc_symbol")
  degGRanges <- GRanges(seqnames = paste0("chr",degCoord$chromosome_name), 
                        ranges = IRanges(start = degCoord$start_position, end = degCoord$end_position),
                        lfc = degCoord$avg_logFC, symbol = degCoord$hgnc_symbol, pval = degCoord$p_val)
  return(degGRanges)
}


PullRegionGRanges <- function(gene, extend) {
  seqlevels <- c(seq(1,24),"X","Y")
  human = useMart("ensembl", dataset = "hsapiens_gene_ensembl")
  bm <- getBM(attributes = c("hgnc_symbol","chromosome_name", "start_position", "end_position","ensembl_gene_id"),
              filters = "hgnc_symbol", values = gene, mart = human) %>%
    dplyr::filter(chromosome_name %in% seqlevels)
  regionStart <- bm$start_position - extend
  regionEnd <- bm$end_position + extend
  chr <- paste0("chr", bm$chromosome_name)
  regionGRanges <- GRanges(chr, paste0(regionStart,"-",regionEnd))
  return(regionGRanges)
}


#' CalculateCoverages
#'
#' Calculate normalized read coverage per base per cell group
#'
#' @param reads Dataframe containing reads for a region, generated by \code{\link{GetReadsInRegion}}
#' @param cells.per.group Number of cells in each group. Must be a named vector. Used for normalization of track heights.
#' @param reads.per.group Average number of reads per group.
#' @param scale.factor Scaling factor for track height. If NULL, use the median group scaling factor
#' determined by total number of fragments sequences in each group.
#' @param window Smoothing window to use
#' @param verbose Display messages
#'
#' @importFrom zoo rollapply
#' @importFrom stats median
#' @importFrom dplyr group_by mutate summarize arrange ungroup
#' @export
CalculateCoverages <- function(
  reads,
  cells.per.group,
  reads.per.group,
  scale.factor = NULL,
  window = 100,
  verbose = TRUE
) {
  if (verbose) {
    message("Computing coverage per base")
  }
  templist <- list()
  y <- 1
  addbases <- 40
  n_allocate <- sum(reads$length)
  templist$position <- rep(x = 0, n_allocate)
  templist$value <- rep(x = 0, n_allocate)
  templist$cell <- rep(x = '0', n_allocate)
  templist$group <- rep(x = '0', n_allocate)
  startpos <- reads[,][['start']]
  endpos <- reads[,][['end']]
  cellnames <- as.character(x = reads[,][['cell']])
  groupnames <- as.character(x = reads[,][['group']])
  for (i in seq_len(length.out = nrow(x = reads))) {
    interval <- (startpos[[i]]-addbases):(endpos[[i]]+addbases)
    for (j in interval) {
      bases_away <- abs(min((j - startpos[[i]]), (endpos[[i]] - j)))
      if ((endpos[[i]] > j) & (j > startpos[[i]])) {
        internal <- TRUE
      } else {
        internal <- FALSE
      }
      templist$position[y] <- j
      templist$value[y] <- WeightAccessibility(
        bases_away = bases_away,
        internal = internal,
        inflection = (addbases/2)
      )
      templist$cell[[y]] <- cellnames[[i]]
      templist$group[[y]] <- groupnames[[i]]
      y <- y + 1
    }
  }
  expanded <- as.data.frame(x = t(x = do.call(what = rbind, args = templist)), stringsAsFactors = FALSE)
  expanded$position <- as.numeric(x = expanded$position)
  expanded$value <- as.numeric(x = expanded$value)
  posrange <- min(expanded$position):max(expanded$position)
  fill_positons <- data.frame(
    position = rep(posrange, length(unique(expanded$group))),
    value = 0,
    cell = NA,
    group = unlist(lapply(unique(expanded$group), function(x) rep(x, length(posrange)))),
    row.names = NULL
  )
  expanded <- rbind(expanded, fill_positons)
  if (is(object = reads$group, class2 = 'factor')) {
    expanded$group <- factor(x = expanded$group, levels = levels(reads$group))
  }
  read_scale <- reads.per.group * cells.per.group
  if (is.null(x = scale.factor)) {
    scale.factor <- median(x = read_scale)
  }
  expanded$norm.value <- expanded$value / read_scale[expanded$group] * scale.factor
  expanded <- group_by(.data = expanded, position, group)
  coverages <- summarize(.data = expanded, total = sum(norm.value))
  coverages <- group_by(.data = coverages, group)
  coverages <- arrange(.data = coverages, position)
  if (!is.na(x = window)) {
    coverages <- mutate(.data = coverages, coverage = rollapply(
      data = total,
      width = window,
      FUN = mean,
      align = 'center',
      fill = NA
    ))
  } else {
    coverages$coverage <- coverages$total
  }
  coverages <- ungroup(x = coverages)
  return(coverages)
}


#' Weight accessibility score based on distance from Tn5 integration site
#'
#' @param bases_away Number of bases from the Tn5 integration site
#' @param internal Whether the postion is within a fragment (TRUE) or flanking a fragment (FALSE)
#' @param rate Rate of score decay. Lower value gives steeper slope in sigmoid function.
#' @param inflection Inflection point for sigmoid weight function. This base will have weight
#' equal to 0.5
WeightAccessibility <- function(bases_away, internal, rate = 2, inflection = 20) {
  bases_away <- bases_away - inflection
  weights <- exp(-bases_away / rate)/(1 + exp(-bases_away / rate))
  weights <- round(x = weights, digits = 3)
  if (weights == 0 & internal) {
    weights <- -0.1
  }
  return(weights)
}


FindCoverageRegion <- function(seuratAtacSub, clusterID, regionGRanges, downsample) {
  Idents(seuratAtacSub) <- "celltype"
  cells <- colnames(x = seuratAtacSub)
  reads <- GetReadsInRegion(seuratAtacSub, assay = 'peaks', region = regionGRanges)
  cells.per.group <- CellsPerGroup(object = seuratAtacSub, group.by = NULL)
  reads.per.group <- AverageCounts(object = seuratAtacSub, group.by = NULL, verbose = FALSE)
  coverages <- suppressWarnings(CalculateCoverages(
    reads = reads,
    cells.per.group = cells.per.group,
    reads.per.group = reads.per.group,
    window = 100,
    verbose = TRUE
  ))
  downsample <- downsample
  chromosome <- as.character(x = seqnames(x = regionGRanges))
  start.pos <- start(x = regionGRanges)
  end.pos <- end(x = regionGRanges)
  stepsize <- 1 / downsample
  total_range <- end.pos - start.pos
  steps <- ceiling(x = (total_range / stepsize))
  retain_positions <- seq(from = start.pos, to = end.pos, by = stepsize)
  downsampled_coverage <- coverages[coverages$position %in% retain_positions, ]
  ymax <- signif(x = max(downsampled_coverage$coverage, na.rm = TRUE), digits = 2)
  downsampled_coverage <- downsampled_coverage[!is.na(x = downsampled_coverage$coverage), ]
  return(downsampled_coverage)
}


PeaksToGvizTrack <- function(downsampled_coverage, clusterID, regionGRanges) {
  chr <- regionGRanges@seqnames@values
  peaks <- dplyr::filter(downsampled_coverage, group ==clusterID)
  peaksGRanges <- GRanges(seqnames = chr, ranges = IRanges(start = peaks$position, width = 1),
                          coverage = peaks$coverage)
  peaksTrack <- DataTrack(range = peaksGRanges, data = "coverage", type = "histogram")
  return(peaksTrack)
}


EncodeTfbsTrack <- function(dacOverlap, name, clusterID = NULL, filter = FALSE) {
  url <- "http://hgdownload.soe.ucsc.edu/goldenPath/hg38/database/encRegTfbsClustered.txt.gz"
  if(file.exists(basename(url))) { # download encode tfbs if not present in environment
    encodeTfbs <- fread(basename(url))
  } else {
    download.file(url, dest = basename(url))
    encodeTfbs <- fread(basename(url))
  }
  
  colnames(encodeTfbs) <- c("bin","chrom","start","end","name","score","sourceCount","sourceIds","sourceScores")
  encodeTfbs <- encodeTfbs[encodeTfbs$chrom == levels(regionGRanges@seqnames@values),] #subset for chromosome of interest to reduce size of df
  encodeTfbsAnno <- makeGRangesFromDataFrame(encodeTfbs)
  encodeTfbsAnno$id <- encodeTfbs$name # add a metadata column with the TF name
  encodeTfbsAnno <- join_overlap_intersect(encodeTfbsAnno, dacOverlap) # subset to dac region of interest
  
  color = "black"
  if(isTRUE(filter)) {
    motifFile <- "analysis_control/motifs.PCT_vs_PTKIM1.xlsx" # calculated by signacAtacFindMotif.R
    enriched.motifs <- read.xlsx(motifFile) %>%
      dplyr::select(motif, fold.enrichment, pvalue, motif.name) %>%
      dplyr::filter(pvalue < 0.05)
    encodeTfbsAnno <- encodeTfbsAnno[encodeTfbsAnno$id %in% enriched.motifs$motif.name, ]  # remove motifs that are not enriched
    color = "darkgreen" # change enriched motifs color to green (all motifs are increased in this list)
  }
  
  if (length(encodeTfbsAnno$tf) > 4) { # tf labels will overlap if there are too many
    encodeTfbsTrack <- AnnotationTrack(encodeTfbsAnno, name = name,
                                       col = color, fill = color, fontcolor = color, id = encodeTfbsAnno$id, showId = FALSE)
  } else {
    encodeTfbsTrack <- AnnotationTrack(encodeTfbsAnno, name = name, id = encodeTfbsAnno$id, 
                                       groupAnnotation = "id", col = color, fill = color, fontcolor = color, showId = FALSE)
  }
  return(encodeTfbsTrack)
}

gene = "VCAM1"
clusterID <- "PT"
seqlevels <- c(seq(1,24),"X","Y")
extend <- 100000 # extend region beyond gene body up- and downstream
downsample <- 100 # reduce number of points to plot for histograms of atac coverage
motifFile <- "" 

# read in snATACseq and snRNAseq datasets after preprocessing
atacAggr <- readRDS("cellranger_atac_prep/chromVar.atacAggr_sub97_control.rds")
fragment.path <- "cellranger_atac_aggr_control/outs/fragments.tsv.gz"
Idents(atacAggr) <- "celltype"
seuratAtacSub <- subset(atacAggr, ident = c("PCT","PT_KIM1"))
seuratAtacSub <- SetFragments(seuratAtacSub, file = fragment.path)

rnaAggr <- readRDS("cellranger_rna_prep/rnaAggr_control.rds")
Idents(rnaAggr) <- "celltype"
DefaultAssay(rnaAggr) <- "SCT"
seuratRnaSub <- subset(rnaAggr, ident = c("PT","PT_KIM1"))


# find dac between PT and PT-KIM1+
DefaultAssay(seuratAtacSub) <- 'peaks'
dac <- FindMarkers(seuratAtacSub, ident.2 = "PCT", ident.1 = "PT_KIM1",
                   test.use = 'LR', latent.vars = "peak_region_fragments") # find dac
dac <- dac[dac$p_val < 0.05, ]
cf <- ClosestFeature(rownames(dac), annotation=EnsDb.Hsapiens.v86, sep=c(':','-'))
dac <- cbind(dac, symbol=cf$gene_name, distance=cf$distance)
dacGRanges <- StringToGRanges(regions = rownames(dac[dac$p_val < 0.05, ]), sep = c(":", "-"))
mcols(dacGRanges)$lfc <- dac$avg_logFC # add the log fold change as a meta data column with Gviz package
mcols(dacGRanges)$closestGene <- dac$symbol
mcols(dacGRanges)$distance <- dac$distance


# find deg between PT and PT-KIM1+
Idents(seuratRnaSub) <- "celltype"
DefaultAssay(seuratRnaSub) <- 'SCT'
deg <- FindMarkers(seuratRnaSub,  ident.2 = "PT", ident.1 = "PT_KIM1") # find all cluster-specific degs for DM2 vs. control
deg <- deg[deg$p_val < 0.05, ]
human = useMart("ensembl", dataset = "hsapiens_gene_ensembl")
bm <- getBM(attributes = c("hgnc_symbol","chromosome_name", "start_position", "end_position","ensembl_gene_id"),
            filters = "hgnc_symbol", values = rownames(deg), mart = human) # get genomic coordinates of degs
deg$hgnc_symbol <- rownames(deg)
degCoord <- merge(bm, deg, by = "hgnc_symbol")
degGRanges <- GRanges(seqnames = paste0("chr",degCoord$chromosome_name), 
                      ranges = IRanges(start = degCoord$start_position, end = degCoord$end_position),
                      lfc = degCoord$avg_logFC, symbol = degCoord$hgnc_symbol, pval = degCoord$p_val)
write.xlsx(deg, file = "analysis_control/deg.PTvPTKIM1.xlsx")



# find differentially expressed motifs between PT and PT-KIM1+
enriched.motifs <- FindMotifs(seuratAtacSub, features = rownames(dac[dac$p_val < 0.05, ]))
write.xlsx(enriched.motifs, file = "analysis_control/motifs.PCT_vs_PTKIM1.xlsx")


# return genomic coords for the gene of interest and extend the coords up- and downstream
regionGRanges <- PullRegionGRanges(gene, extend)


# determine the atac peak coverage within the region of interest
downsampled_coverage <- FindCoverageRegion(seuratAtacSub, clusterID = NULL, regionGRanges, downsample) 
downsampled_coverage1 <- dplyr::filter(downsampled_coverage, group == "PCT")
downsampled_coverage2 <- dplyr::filter(downsampled_coverage, group == "PT_KIM1")



# create Gviz tracks for PT and PT-KIM1+ out of the downsampled peaks to plot with GViz
peakTrackPTKIM1 <- PeaksToGvizTrack(downsampled_coverage2, clusterID = "PT_KIM1", regionGRanges)
peakTrackPTKIM1@name <- "PT_KIM1"
peakTrackPT <- PeaksToGvizTrack(downsampled_coverage1, clusterID = "PCT", regionGRanges)
peakTrackPT@name <- "PT"
ymax <- max(peakTrackPTKIM1@data, peakTrackPT@data) # determine max peak height to scale data tracks


degOverlap <- join_overlap_intersect(degGRanges, regionGRanges) %>%
  dplyr::filter(symbol == gene)
degTrack <- DataTrack(range = degOverlap, data = "lfc", genome = "hg38")

# generate a track of diff. access. chromatin between DM vs. Ctrl that overlap with region
dacOverlap <- join_overlap_intersect(dacGRanges, regionGRanges)
dacTrack <- DataTrack(range = dacOverlap, data = "lfc", genome = "hg38") 

# select color for generegiontrack fill based on whether the gene in the degTrack is up- or down-regulated
colorDeg = "darkgray"
if (is.null(degOverlap$lfc)) {
  print("No differentially expressed genes present")
  colorDeg = "darkgray"
} else if (degOverlap$lfc > 0) {
  print ("Gene is upregulated")
  colorDeg = "darkgreen"
} else if (degOverlap$lfc < 0) {
  print("Gene is downregulated")
  colorDeg = "darkred"
} 



# set up annotation tracks
# filters <- AnnotationFilterList(GeneBiotypeFilter(value = 'protein_coding'), SeqNameFilter(chr))
edb <- EnsDb.Hsapiens.v86
filters <- AnnotationFilterList(GeneNameFilter(gene))
gr <- getGeneRegionTrackForGviz(edb, filter = filters)
# gr <- getGeneRegionTrackForGviz(edb, chromosome = chr, start = regionStart, end = regionEnd)
# gr@seqnames@values <- paste0("chr", gr@seqnames@values) # change contigs to ucsc standard
# gr <- renameSeqlevels(gr, chr) # change contigs to ucsc standard
grTrack <- GeneRegionTrack(range = gr, transcriptAnnotation = "symbol", feature = "gene",
                           name = gene, collapseTranscripts = "longest", shape = "arrow", fill = colorDeg, col = colorDeg, stacking = "dense")
grTrack <- grTrack[symbol(grTrack) == gene] # remove gene models that are up- or downstream of desired gene
displayPars(grTrack) <- list(size=2) # ensure track is large enough to display gene name


# add a GWAS track for a SNP in HIST1H2AC assoc with HTN
gwas <- StringToGRanges("chr6:26132842-26132842", sep = c(":", "-"))
gwasTrack <- AnnotationTrack(gwas, name = "GWAS")

# create a track that encodes the genomic coordinates and a track with an ideogram
axTrack <- GenomeAxisTrack()
idxTrack <- IdeogramTrack(genome="hg38", chromosome=chr)


# annotate with encode transcription factor chip-seq peaks using the ucsc genome annotations
# see additional options here: http://hgdownload.soe.ucsc.edu/goldenPath/hg38/database/
# This track shows regions of transcription factor binding derived from a large collection of 
# ChIP-seq experiments performed by the ENCODE project between February 2011 and November 2018, 
# spanning the first production phase of ENCODE ("ENCODE 2") through the second full production phase ("ENCODE 3").
# load reference genomes
# find tfbs in diff. access regions filter parameter will select only enriched motifs in the dac areas
tfbsTrack <- EncodeTfbsTrack(dacOverlap, name = "TFBS", clusterID = clusterID, filter = TRUE)

# create an overlay track
overlay <- OverlayTrack(trackList = c(peakTrackPT, peakTrackPTKIM1))


# set chromosome, regionStart, and regionEnd variables and plot individual tracks
chr <- levels(regionGRanges@seqnames@values)
regionStart <- start(regionGRanges)
regionEnd <- end(regionGRanges)

# read in cicero connections generated by ciceroFindConns.R
connsFile1 <- paste0("analysis_control/ccan/ciceroConns.control.PT.csv")
conns1 <- fread(connsFile1) 
c1f <- dplyr::filter(conns1, grepl(chr, Peak1))

connsFile2 <- paste0("analysis_control/ccan/ciceroConns.control.PT_KIM1.csv")
conns2 <- fread(connsFile2)
c2f <- dplyr::filter(conns2, grepl(chr, Peak1))


# create highlights using the dac track
ymax <- max(peakTrackPT@data, peakTrackPTKIM1@data) # scale y axis for peaks
hltrack = HighlightTrack(trackList = list(peakTrackPT, peakTrackPTKIM1), range = dacOverlap) 
hl1 <- HighlightTrack(trackList = peakTrackPT, range = dacOverlap, ylim = c(0,ymax))
hl2 <- HighlightTrack(trackList = peakTrackPTKIM1, range = dacOverlap, ylim = c(0,ymax))



# create integrated plot of all tracks
plots <- plot_connections(c1f, chr, regionStart, regionEnd, 
                          comparison_track = c2f, return_as_list = TRUE, coaccess_cutoff = 0.20, comparison_coaccess_cutoff = 0.20, alpha_by_coaccess = FALSE, 
                          connection_ymax = 1.0, comparison_ymax = 1.0) 
# if coaccess cutoff is too high
# cicero may throw an error that reads "1: In max(sub2$height, na.rm = TRUE) :
#  no non-missing arguments to max; returning -Inf
# 2: In plot_connections(c1, chr, regionStart, regionEnd, comparison_track = c2,  :
#  comparison_ymax calc failed"
displayPars(plots[[1]]) <- list(size=2) # increase height of connection tracks in plot
displayPars(plots[[4]]) <- list(size=2)

plots[[3]] <- hl1
plots[[6]] <- hl2
# plots[[7]] <- tfbsTrack
plots[[7]] <- grTrack


plots[[1]]@dp@pars$name <- "PT"
plots[[4]]@dp@pars$name <- "PT_KIM1"

geneModelFile <- paste0("geneModel.tf.conns.",gene,".","PTvPTKIM1",".pdf")
pdf(file = geneModelFile)
plotTracks(plots, chr, from = regionStart, to = regionEnd, ylim = c(0,ymax))
dev.off()

geneModelFile <- paste0("geneModel.conns.",gene,".","PTvPTKIM1",".png")
png(file = geneModelFile, type = "cairo")
plotTracks(plots, chr, from = regionStart, to= regionEnd, ylim = c(0,ymax))
dev.off()

toplot <- c(plots[[1]],plots[[2]],plots[[3]],plots[[4]],plots[[5]],plots[[6]],plots[[8]])
geneModelFile <- paste0("geneModel.conns.",gene,".","PTvPTKIM1",".pdf")
pdf(file = geneModelFile)
plotTracks(toplot, chr, from = regionStart, to = regionEnd, ylim = c(0,ymax))
dev.off()


toplot <- c(plots[[1]],plots[[2]],plots[[3]],plots[[4]],plots[[5]],plots[[6]],plots[[8]])
geneModelFile <- paste0("geneModel.conns.",gene,".","PTvPTKIM1",".png")
png(file = geneModelFile)
plotTracks(toplot, chr, from = regionStart, to = regionEnd, ylim = c(0,ymax))
dev.off()

toplot <- c(plots[[3]],plots[[6]],plots[[8]])
geneModelFile <- paste0("geneModel.",gene,".","PTvPTKIM1",".pdf")
pdf(file = geneModelFile)
plotTracks(toplot, chr, from = regionStart, to = regionEnd, ylim = c(0,ymax))
dev.off()







